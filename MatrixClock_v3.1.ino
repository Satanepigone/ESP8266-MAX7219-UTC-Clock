/* MatrixClock V3.1
 original from https:			//github.com/schreibfaul1/ESP8266-LED-Matrix-Clock
 small changes by Nicu FLORICA (niq_ro) from https:			//github.com/tehniq3/
 and Bogdan ARGATU
 
========================================================
WiFi led to ESP8266
========================================================
catode - D3  , anode to 3.3v with a 1k resistor
*/
/* 
for disable scrolling calendar, search for "scroll switch", and change true to false.
for adjust LED brightness, search for “max7219_set_brightness(1)”，chagne 1 to integer between 0~15, 0 for darkest, 15 for brightest.
*********************************************************************************************************/

//include ----------------------------------------
#include <SPI.h>
#include <Ticker.h>
#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <WiFiUdp.h>
#include <Wire.h>
#include <time.h>

// GPIO define
#define SDA        4			// Pin sda (I2C)
#define SCL        5			// Pin scl (I2C)
#define CS        15			// Pin cs  (SPI)
#define anzMAX     4			// number of led matrix Modules
//anz means num in German

#define REVERSE_HORIZONTAL			//if you use hardware v2.2 board you need delete this line
#define REVERSE_VERTICAL			//if you use hardware v2.2 board you need delete this line

char ssid[] = "";			// your Wi-FiSSID (name)
char pass[] = "";			// your Wi-Fi password
/****************************************/
// # CONSTANT DEFINE 常量定义

// ## Address Map of RTC DS3231
const unsigned char DS3231_ADDRESS = 0x68;
const unsigned char secondREG = 0x00;
const unsigned char minuteREG = 0x01;
const unsigned char hourREG = 0x02;
const unsigned char WDREG = 0x03;			//weekday
const unsigned char dateREG = 0x04;
const unsigned char monthREG = 0x05;
const unsigned char yearREG = 0x06;
const unsigned char alarm_1_secREG = 0x07;
const unsigned char alarm_1_minREG = 0x08;
const unsigned char alarm_1_hrREG = 0x09;
const unsigned char alarm_1_dateREG = 0x0A;
const unsigned char alarm_2_minREG = 0x0B;
const unsigned char alarm_2_hrREG = 0x0C;
const unsigned char alarm_2_dateREG = 0x0D;
const unsigned char controlREG = 0x0E;
const unsigned char statusREG = 0x0F;
const unsigned char ageoffsetREG = 0x10;
const unsigned char tempMSBREG = 0x11;
const unsigned char tempLSBREG = 0x12;
const unsigned char _24_hour_format = 0;
const unsigned char _12_hour_format = 1;
const unsigned char AM = 0;
const unsigned char PM = 1;

// ## Font/Typeface 字体
	// 字体-x
	// Character set 5x8 in an 8x8 matrix, 0.0 is at the top right
	// 在8x8矩阵中，使用5x8的字符, 0,0原点设置在右上角
unsigned short const FONT5x8[96][9] = { 
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x20, Space
		{ 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },			// 0x21, !
		{ 0x07, 0x09, 0x09, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x22, "
		{ 0x07, 0x0a, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0x0a, 0x00 },			// 0x23, #
		{ 0x07, 0x04, 0x0f, 0x14, 0x0e, 0x05, 0x1e, 0x04, 0x00 },			// 0x24, $
		{ 0x07, 0x19, 0x19, 0x02, 0x04, 0x08, 0x13, 0x13, 0x00 },			// 0x25, %
		{ 0x07, 0x04, 0x0a, 0x0a, 0x0a, 0x15, 0x12, 0x0d, 0x00 },			// 0x26, &
		{ 0x07, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x27, '
		{ 0x07, 0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, 0x00 },			// 0x28, (
		{ 0x07, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00 },			// 0x29, )
		{ 0x07, 0x04, 0x15, 0x0e, 0x1f, 0x0e, 0x15, 0x04, 0x00 },			// 0x2a, *
		{ 0x07, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x00 },			// 0x2b, +
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02 },			// 0x2c, ,
		{ 0x07, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00 },			// 0x2d, -
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00 },			// 0x2e, .
		{ 0x07, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00 },			// 0x2f, /
		{ 0x07, 0x0F, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0F, 0x00 },			// 0x30, 0
		{ 0x07, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x31, 1
		{ 0x07, 0x0F, 0x01, 0x01, 0x0F, 0x08, 0x08, 0x0F, 0x00 },			// 0x32, 2
		{ 0x07, 0x0F, 0x01, 0x01, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x33, 3
		{ 0x07, 0x09, 0x09, 0x09, 0x0F, 0x01, 0x01, 0x01, 0x00 },			// 0x34, 4
		{ 0x07, 0x0F, 0x08, 0x08, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x35, 5
		{ 0x07, 0x0F, 0x08, 0x08, 0x0F, 0x09, 0x09, 0x0F, 0x00 },			// 0x36, 6
		{ 0x07, 0x0F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00 },			// 0x37, 7
		{ 0x07, 0x0F, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x0F, 0x00 },			// 0x38, 8
		{ 0x07, 0x0F, 0x09, 0x09, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x39, 9
		{ 0x04, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00 },			// 0x3a, :
		{ 0x07, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x04, 0x08, 0x00 },			// 0x3b, ;
		{ 0x07, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00 },			// 0x3c, <
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x3d, =
		{ 0x07, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x00 },			// 0x3e, >
		{ 0x07, 0x0e, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, 0x00 },			// 0x3f, ?
		{ 0x07, 0x0e, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0f, 0x00 },			// 0x40, @
		{ 0x07, 0x04, 0x0a, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00 },			// 0x41, A
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x1e, 0x00 },			// 0x42, B
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00 },			// 0x43, C
		{ 0x07, 0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E, 0x00 },			// 0x44, D
		{ 0x07, 0x1f, 0x10, 0x10, 0x1c, 0x10, 0x10, 0x1f, 0x00 },			// 0x45, E
		{ 0x07, 0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x10, 0x00 },			// 0x46, F
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x13, 0x11, 0x0f, 0x00 },			// 0x37, G
		{ 0x07, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00 },			// 0x48, H
		{ 0x07, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0e, 0x00 },			// 0x49, I
		{ 0x07, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0c, 0x00 },			// 0x4a, J
		{ 0x07, 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00 },			// 0x4b, K
		{ 0x07, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x00 },			// 0x4c, L
		{ 0x07, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00 },			// 0x4d, M
		{ 0x07, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00 },			// 0x4e, N
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x4f, O
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10, 0x00 },			// 0x50, P
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0d, 0x00 },			// 0x51, Q
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x14, 0x12, 0x11, 0x00 },			// 0x52, R
		{ 0x07, 0x0e, 0x11, 0x10, 0x0e, 0x01, 0x11, 0x0e, 0x00 },			// 0x53, S
		{ 0x07, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x54, T
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x55, U
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x56, V
		{ 0x07, 0x11, 0x11, 0x11, 0x15, 0x15, 0x1b, 0x11, 0x00 },			// 0x57, W
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00 },			// 0x58, X
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x59, Y
		{ 0x07, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1f, 0x00 },			// 0x5a, Z
		{ 0x07, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00 },			// 0x5b, [
		{ 0x07, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x00 },			// 0x5c, '\'
		{ 0x07, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0e, 0x00 },			// 0x5d, ]
		{ 0x07, 0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x5e, ^
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00 },			// 0x5f, _
		{ 0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x60, `
		{ 0x07, 0x00, 0x0e, 0x01, 0x0d, 0x13, 0x13, 0x0d, 0x00 },			// 0x61, a
		{ 0x07, 0x10, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00 },			// 0x62, b
		{ 0x07, 0x00, 0x00, 0x0E, 0x10, 0x10, 0x10, 0x0E, 0x00 },			// 0x63, c
		{ 0x07, 0x01, 0x01, 0x01, 0x07, 0x09, 0x09, 0x07, 0x00 },			// 0x64, d
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0f, 0x00 },			// 0x65, e
		{ 0x07, 0x06, 0x09, 0x08, 0x1c, 0x08, 0x08, 0x08, 0x00 },			// 0x66, f
		{ 0x07, 0x00, 0x0e, 0x11, 0x13, 0x0d, 0x01, 0x01, 0x0e },			// 0x67, g
		{ 0x07, 0x10, 0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x00 },			// 0x68, h
		{ 0x05, 0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x0e, 0x00 },			// 0x69, i
		{ 0x07, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0c },			// 0x6a, j
		{ 0x07, 0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00 },			// 0x6b, k
		{ 0x05, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x6c, l
		{ 0x07, 0x00, 0x00, 0x0a, 0x15, 0x15, 0x11, 0x11, 0x00 },			// 0x6d, m
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00 },			// 0x6e, n
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x6f, o
		{ 0x07, 0x00, 0x00, 0x1c, 0x12, 0x12, 0x1c, 0x10, 0x10 },			// 0x70, p
		{ 0x07, 0x00, 0x00, 0x07, 0x09, 0x09, 0x07, 0x01, 0x01 },			// 0x71, q
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, 0x00 },			// 0x72, r
		{ 0x07, 0x00, 0x00, 0x0f, 0x10, 0x0e, 0x01, 0x1e, 0x00 },			// 0x73, s
		{ 0x07, 0x08, 0x08, 0x1c, 0x08, 0x08, 0x09, 0x06, 0x00 },			// 0x74, t
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0x00 },			// 0x75, u
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x76, v
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00 },			// 0x77, w
		{ 0x07, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00 },			// 0x78, x
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0x11, 0x0e },			// 0x79, y
		{ 0x07, 0x00, 0x00, 0x1f, 0x02, 0x04, 0x08, 0x1f, 0x00 },			// 0x7a, z
		{ 0x07, 0x06, 0x08, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00 },			// 0x7b, {
		{ 0x07, 0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00 },			// 0x7c, |
		{ 0x07, 0x0c, 0x02, 0x02, 0x01, 0x02, 0x02, 0x0c, 0x00 },			// 0x7d, }
		{ 0x07, 0x08, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x7e, ~
		{ 0x07, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00 }			// 0x7f, DEL
};

	// 字体1
	// Zeichensatz 5x8 in einer 8x8 Matrix, 0,0 ist rechts oben
	// 在8x8矩阵中，使用5x8的字符, 0,0原点设置在右上角
unsigned short const font1[96][9] = { 
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x20, Space
		{ 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },			// 0x21, !
		{ 0x07, 0x09, 0x09, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x22, "
		{ 0x07, 0x0a, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0x0a, 0x00 },			// 0x23, #
		{ 0x07, 0x04, 0x0f, 0x14, 0x0e, 0x05, 0x1e, 0x04, 0x00 },			// 0x24, $
		{ 0x07, 0x19, 0x19, 0x02, 0x04, 0x08, 0x13, 0x13, 0x00 },			// 0x25, %
		{ 0x07, 0x04, 0x0a, 0x0a, 0x0a, 0x15, 0x12, 0x0d, 0x00 },			// 0x26, &
		{ 0x07, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x27, '
		{ 0x07, 0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, 0x00 },			// 0x28, (
		{ 0x07, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00 },			// 0x29, )
		{ 0x07, 0x04, 0x15, 0x0e, 0x1f, 0x0e, 0x15, 0x04, 0x00 },			// 0x2a, *
		{ 0x07, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x00 },			// 0x2b, +
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02 },			// 0x2c, ,
		{ 0x07, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00 },			// 0x2d, -
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00 },			// 0x2e, .
		{ 0x07, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00 },			// 0x2f, /
		{ 0x07, 0x0F, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0F, 0x00 },			// 0x30, 0
		{ 0x07, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x31, 1
		{ 0x07, 0x0F, 0x01, 0x01, 0x0F, 0x08, 0x08, 0x0F, 0x00 },			// 0x32, 2
		{ 0x07, 0x0F, 0x01, 0x01, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x33, 3
		{ 0x07, 0x09, 0x09, 0x09, 0x0F, 0x01, 0x01, 0x01, 0x00 },			// 0x34, 4
		{ 0x07, 0x0F, 0x08, 0x08, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x35, 5
		{ 0x07, 0x0F, 0x08, 0x08, 0x0F, 0x09, 0x09, 0x0F, 0x00 },			// 0x36, 6
		{ 0x07, 0x0F, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00 },			// 0x37, 7
		{ 0x07, 0x0F, 0x09, 0x09, 0x0F, 0x09, 0x09, 0x0F, 0x00 },			// 0x38, 8
		{ 0x07, 0x0F, 0x09, 0x09, 0x0F, 0x01, 0x01, 0x0F, 0x00 },			// 0x39, 9
		{ 0x04, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00 },			// 0x3a, :
		{ 0x07, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x04, 0x08, 0x00 },			// 0x3b, ;
		{ 0x07, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00 },			// 0x3c, <
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x3d, =
		{ 0x07, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x00 },			// 0x3e, >
		{ 0x07, 0x0e, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, 0x00 },			// 0x3f, ?
		{ 0x07, 0x0e, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0f, 0x00 },			// 0x40, @
		{ 0x07, 0x04, 0x0a, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00 },			// 0x41, A
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x1e, 0x00 },			// 0x42, B
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00 },			// 0x43, C
		{ 0x07, 0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E, 0x00 },			// 0x44, D
		{ 0x07, 0x1f, 0x10, 0x10, 0x1c, 0x10, 0x10, 0x1f, 0x00 },			// 0x45, E
		{ 0x07, 0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x10, 0x00 },			// 0x46, F
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x13, 0x11, 0x0f, 0x00 },			// 0x37, G
		{ 0x07, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00 },			// 0x48, H
		{ 0x07, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0e, 0x00 },			// 0x49, I
		{ 0x07, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0c, 0x00 },			// 0x4a, J
		{ 0x07, 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00 },			// 0x4b, K
		{ 0x07, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x00 },			// 0x4c, L
		{ 0x07, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00 },			// 0x4d, M
		{ 0x07, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00 },			// 0x4e, N
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x4f, O
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10, 0x00 },			// 0x50, P
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0d, 0x00 },			// 0x51, Q
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x14, 0x12, 0x11, 0x00 },			// 0x52, R
		{ 0x07, 0x0e, 0x11, 0x10, 0x0e, 0x01, 0x11, 0x0e, 0x00 },			// 0x53, S
		{ 0x07, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x54, T
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x55, U
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x56, V
		{ 0x07, 0x11, 0x11, 0x11, 0x15, 0x15, 0x1b, 0x11, 0x00 },			// 0x57, W
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00 },			// 0x58, X
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x59, Y
		{ 0x07, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1f, 0x00 },			// 0x5a, Z
		{ 0x07, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00 },			// 0x5b, [
		{ 0x07, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x00 },			// 0x5c, '\'
		{ 0x07, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0e, 0x00 },			// 0x5d, ]
		{ 0x07, 0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x5e, ^
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00 },			// 0x5f, _
		{ 0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x60, `
		{ 0x07, 0x00, 0x0e, 0x01, 0x0d, 0x13, 0x13, 0x0d, 0x00 },			// 0x61, a
		{ 0x07, 0x10, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00 },			// 0x62, b
		{ 0x07, 0x00, 0x00, 0x0E, 0x10, 0x10, 0x10, 0x0E, 0x00 },			// 0x63, c
		{ 0x07, 0x01, 0x01, 0x01, 0x07, 0x09, 0x09, 0x07, 0x00 },			// 0x64, d
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0f, 0x00 },			// 0x65, e
		{ 0x07, 0x06, 0x09, 0x08, 0x1c, 0x08, 0x08, 0x08, 0x00 },			// 0x66, f
		{ 0x07, 0x00, 0x0e, 0x11, 0x13, 0x0d, 0x01, 0x01, 0x0e },			// 0x67, g
		{ 0x07, 0x10, 0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x00 },			// 0x68, h
		{ 0x05, 0x00, 0x04, 0x00, 0x0C, 0x04, 0x04, 0x0e, 0x00 },			// 0x69, i
		{ 0x07, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0c },			// 0x6a, j
		{ 0x07, 0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00 },			// 0x6b, k
		{ 0x05, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x6c, l
		{ 0x07, 0x00, 0x00, 0x0a, 0x15, 0x15, 0x11, 0x11, 0x00 },			// 0x6d, m
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00 },			// 0x6e, n
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x6f, o
		{ 0x07, 0x00, 0x00, 0x1c, 0x12, 0x12, 0x1c, 0x10, 0x10 },			// 0x70, p
		{ 0x07, 0x00, 0x00, 0x07, 0x09, 0x09, 0x07, 0x01, 0x01 },			// 0x71, q
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, 0x00 },			// 0x72, r
		{ 0x07, 0x00, 0x00, 0x0f, 0x10, 0x0e, 0x01, 0x1e, 0x00 },			// 0x73, s
		{ 0x07, 0x08, 0x08, 0x1c, 0x08, 0x08, 0x09, 0x06, 0x00 },			// 0x74, t
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0x00 },			// 0x75, u
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x76, v
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00 },			// 0x77, w
		{ 0x07, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00 },			// 0x78, x
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0x11, 0x0e },			// 0x79, y
		{ 0x07, 0x00, 0x00, 0x1f, 0x02, 0x04, 0x08, 0x1f, 0x00 },			// 0x7a, z
		{ 0x07, 0x06, 0x08, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00 },			// 0x7b, {
		{ 0x07, 0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00 },			// 0x7c, |
		{ 0x07, 0x0c, 0x02, 0x02, 0x01, 0x02, 0x02, 0x0c, 0x00 },			// 0x7d, }
		{ 0x07, 0x08, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x7e, ~
		{ 0x07, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00 }			// 0x7f, DEL
};

	// 字体2 小字
	// Zeichensatz 5x8 in einer 8x8 Matrix, 0,0 ist rechts oben
	// 在8x8矩阵中，使用5x8的字符, 0,0原点设置在右上角
unsigned short const font2[96][9] = { 
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x20, Space
		{ 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },			// 0x21, !
		{ 0x07, 0x09, 0x09, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x22, "
		{ 0x07, 0x0a, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0x0a, 0x00 },			// 0x23, #
		{ 0x07, 0x04, 0x0f, 0x14, 0x0e, 0x05, 0x1e, 0x04, 0x00 },			// 0x24, $
		{ 0x07, 0x19, 0x19, 0x02, 0x04, 0x08, 0x13, 0x13, 0x00 },			// 0x25, %
		{ 0x07, 0x04, 0x0a, 0x0a, 0x0a, 0x15, 0x12, 0x0d, 0x00 },			// 0x26, &
		{ 0x07, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x27, '
		{ 0x07, 0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, 0x00 },			// 0x28, (
		{ 0x07, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00 },			// 0x29, )
		{ 0x07, 0x04, 0x15, 0x0e, 0x1f, 0x0e, 0x15, 0x04, 0x00 },			// 0x2a, *
		{ 0x07, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x00 },			// 0x2b, +
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02 },			// 0x2c, ,
		{ 0x07, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00 },			// 0x2d, -
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00 },			// 0x2e, .
		{ 0x07, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00 },			// 0x2f, /
		{ 0x07, 0x00, 0x00, 0x07, 0x05, 0x05, 0x05, 0x07, 0x00 },			// 0x30, 0
		{ 0x07, 0x00, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x31, 1
		{ 0x07, 0x00, 0x00, 0x07, 0x01, 0x07, 0x04, 0x07, 0x00 },			// 0x32, 2
		{ 0x07, 0x00, 0x00, 0x07, 0x01, 0x07, 0x01, 0x07, 0x00 },			// 0x33, 3
		{ 0x07, 0x00, 0x00, 0x05, 0x05, 0x07, 0x01, 0x01, 0x00 },			// 0x34, 4
		{ 0x07, 0x00, 0x00, 0x07, 0x04, 0x07, 0x01, 0x07, 0x00 },			// 0x35, 5
		{ 0x07, 0x00, 0x00, 0x07, 0x04, 0x07, 0x05, 0x07, 0x00 },			// 0x36, 6
		{ 0x07, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x00 },			// 0x37, 7
		{ 0x07, 0x00, 0x00, 0x07, 0x05, 0x07, 0x05, 0x07, 0x00 },			// 0x38, 8
		{ 0x07, 0x00, 0x00, 0x07, 0x05, 0x07, 0x01, 0x07, 0x00 },			// 0x39, 9
		{ 0x04, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00 },			// 0x3a, :
		{ 0x07, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x04, 0x08, 0x00 },			// 0x3b, ;
		{ 0x07, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00 },			// 0x3c, <
		{ 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x3d, =
		{ 0x07, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x00 },			// 0x3e, >
		{ 0x07, 0x0e, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, 0x00 },			// 0x3f, ?
		{ 0x07, 0x0e, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0f, 0x00 },			// 0x40, @
		{ 0x07, 0x04, 0x0a, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00 },			// 0x41, A
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x1e, 0x00 },			// 0x42, B
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00 },			// 0x43, C
		{ 0x07, 0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E, 0x00 },			// 0x44, D
		{ 0x07, 0x1f, 0x10, 0x10, 0x1c, 0x10, 0x10, 0x1f, 0x00 },			// 0x45, E
		{ 0x07, 0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x10, 0x00 },			// 0x46, F
		{ 0x07, 0x0e, 0x11, 0x10, 0x10, 0x13, 0x11, 0x0f, 0x00 },			// 0x37, G
		{ 0x07, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00 },			// 0x48, H
		{ 0x07, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0e, 0x00 },			// 0x49, I
		{ 0x07, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0c, 0x00 },			// 0x4a, J
		{ 0x07, 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00 },			// 0x4b, K
		{ 0x07, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x00 },			// 0x4c, L
		{ 0x07, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00 },			// 0x4d, M
		{ 0x07, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00 },			// 0x4e, N
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x4f, O
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10, 0x00 },			// 0x50, P
		{ 0x07, 0x0e, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0d, 0x00 },			// 0x51, Q
		{ 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x14, 0x12, 0x11, 0x00 },			// 0x52, R
		{ 0x07, 0x0e, 0x11, 0x10, 0x0e, 0x01, 0x11, 0x0e, 0x00 },			// 0x53, S
		{ 0x07, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x54, T
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x55, U
		{ 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x56, V
		{ 0x07, 0x11, 0x11, 0x11, 0x15, 0x15, 0x1b, 0x11, 0x00 },			// 0x57, W
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00 },			// 0x58, X
		{ 0x07, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00 },			// 0x59, Y
		{ 0x07, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1f, 0x00 },			// 0x5a, Z
		{ 0x07, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00 },			// 0x5b, [
		{ 0x07, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x00 },			// 0x5c, '\'
		{ 0x07, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0e, 0x00 },			// 0x5d, ]
		{ 0x07, 0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x5e, ^
		{ 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00 },			// 0x5f, _
		{ 0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x60, `
		{ 0x07, 0x00, 0x0e, 0x01, 0x0d, 0x13, 0x13, 0x0d, 0x00 },			// 0x61, a
		{ 0x07, 0x10, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00 },			// 0x62, b
		{ 0x07, 0x00, 0x00, 0x0E, 0x10, 0x10, 0x10, 0x0E, 0x00 },			// 0x63, c
		{ 0x07, 0x01, 0x01, 0x01, 0x07, 0x09, 0x09, 0x07, 0x00 },			// 0x64, d
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0f, 0x00 },			// 0x65, e
		{ 0x07, 0x06, 0x09, 0x08, 0x1c, 0x08, 0x08, 0x08, 0x00 },			// 0x66, f
		{ 0x07, 0x00, 0x0e, 0x11, 0x13, 0x0d, 0x01, 0x01, 0x0e },			// 0x67, g
		{ 0x07, 0x10, 0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x00 },			// 0x68, h
		{ 0x05, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x07, 0x00 },			// 0x69, i
		{ 0x07, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0c },			// 0x6a, j
		{ 0x07, 0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00 },			// 0x6b, k
		{ 0x05, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },			// 0x6c, l
		{ 0x07, 0x00, 0x00, 0x0a, 0x15, 0x15, 0x11, 0x11, 0x00 },			// 0x6d, m
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00 },			// 0x6e, n
		{ 0x07, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00 },			// 0x6f, o
		{ 0x07, 0x00, 0x00, 0x1c, 0x12, 0x12, 0x1c, 0x10, 0x10 },			// 0x70, p
		{ 0x07, 0x00, 0x00, 0x07, 0x09, 0x09, 0x07, 0x01, 0x01 },			// 0x71, q
		{ 0x07, 0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, 0x00 },			// 0x72, r
		{ 0x07, 0x00, 0x00, 0x0f, 0x10, 0x0e, 0x01, 0x1e, 0x00 },			// 0x73, s
		{ 0x07, 0x08, 0x08, 0x1c, 0x08, 0x08, 0x09, 0x06, 0x00 },			// 0x74, t
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0x00 },			// 0x75, u
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },			// 0x76, v
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00 },			// 0x77, w
		{ 0x07, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00 },			// 0x78, x
		{ 0x07, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0x11, 0x0e },			// 0x79, y
		{ 0x07, 0x00, 0x00, 0x1f, 0x02, 0x04, 0x08, 0x1f, 0x00 },			// 0x7a, z
		{ 0x07, 0x06, 0x08, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00 },			// 0x7b, {
		{ 0x07, 0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00 },			// 0x7c, |
		{ 0x07, 0x0c, 0x02, 0x02, 0x01, 0x02, 0x02, 0x0c, 0x00 },			// 0x7d, }
		{ 0x07, 0x08, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },			// 0x7e, ~
		{ 0x07, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00 }			// 0x7f, DEL
};

/****************************************/
unsigned short maxPosX = anzMAX * 8 - 1;			//calculated maxposition
unsigned short LEDarr[anzMAX][8];			//character matrix to display (40*8)
unsigned short helpArrMAX[anzMAX * 8];			//helperarray for chardecoding
unsigned short helpArrPos[anzMAX * 8];			//helperarray pos of chardecoding
unsigned int t_PosX = 0;			//xPosition in Display for time display
unsigned int d_PosX = 0;			//xPosition in Display for date display
bool f_tckr1s = false;			//1 second flag
bool f_tckr50ms = false;			//50 ms flag
unsigned long epoch = 0;
unsigned int localPort = 2390;			// local port to listen for UDP packets
const char* ntpServerName = "time.nist.gov";
const int NTP_PACKET_SIZE = 48;			// NTP time stamp is in the first 48 bytes of the message
byte packetBuffer[NTP_PACKET_SIZE];			// buffer to hold incoming and outgoing packets
IPAddress timeServerIP;			// time.nist.gov NTP server address
tm *tt, ttm;


struct DateTime {
	unsigned short sec_ones, sec_tens, sec_whole, min_ones, min_tens, min_whole, hr_ones, hr_tens, hr_whole;
	unsigned short day_ones, day_tens, day_whole, mon_ones, mon_tens, mon_whole, year_ones, year_tens, year_whole, WD;
} MEZ;


// The object for the Ticker
Ticker tckr;
// A UDP instance to let us send and receive packets over UDP
WiFiUDP udp;


//Months
char M_arr[12][3] = {
  {'0', '1', '-'}, {'0', '2', '-'}, {'0', '3', '-'}, 
  {'0', '4', '-'}, {'0', '5', '-'}, {'0', '6', '-'}, 
  {'0', '7', '-'}, {'0', '8', '-'}, {'0', '9', '-'}, 
  {'1', '0', '-'}, {'1', '1', '-'}, {'1', '2', '-'} };
//WeekDays
char WD_arr[7][4] = {
  {'S', 'U', 'N', ' '}, 
  {'M', 'O', 'N', ' '}, 
  {'T', 'U', 'E', ' '}, 
  {'W', 'E', 'D', ' '}, 
  {'T', 'H', 'U', ' '}, 
  {'F', 'R', 'I', ' '}, 
  {'S', 'A', 'T', ' '} };


//**************************************************************************************************
//declare char2Arr
void char2Arr(unsigned short ch, int PosX, short PosY, unsigned short const typeface[96][9] = font1 );
void char22Arr(unsigned short ch, int PosX, short PosY);
//**************************************************************************************************
//Auto Config Wi-Fi 自动配网
bool autoConfig()
{
	WiFi.begin();			// We start by connecting to a WiFi network

	for (int i = 0; i < 10; i++)
	{
	   char2Arr('W', 28, 0);
	   char2Arr('i', 21, 0);
	   char2Arr('-', 18, 0);
	   char2Arr('F', 12, 0);
	   char2Arr('i', 6, 0);

	   refresh_display(); 
	   
	   if (WiFi.status() == WL_CONNECTED)
	   {
		  Serial.println("AutoConfig Success");
		  Serial.printf("SSID:%s\r\n", WiFi.SSID().c_str());
		  Serial.printf("PSW:%s\r\n", WiFi.psk().c_str());
		  clear_Display();
		  char2Arr('O', 25, 0);
		  char2Arr('K', 19, 0);
		  char2Arr('!', 12, 0);
		  char2Arr('!', 6, 0);
		  refresh_display(); 

		  Serial.println("WiFi connected");
		  Serial.println(WiFi.localIP());
		  Serial.println("Starting UDP");
		  udp.begin(localPort);
		  Serial.print("Local port: ");
		  Serial.println(udp.localPort());
		  return true;
	   }
	   else{
		  Serial.print("AutoConfig Waiting......");
		  Serial.println(WiFi.status());
		  delay(1000);
	   }
	}
	clear_Display();
	char2Arr('E', 25, 0);
	char2Arr('r', 19, 0);
	char2Arr('r', 12, 0);
	char2Arr('!', 6, 0);
	refresh_display(); 
	delay(1000);
	Serial.println("AutoConfig Faild!" );
	return false;
}
//**************************************************************************************************
// Smart Config 智能配网
void smartConfig()
{
	int i = 0;
  
	WiFi.mode(WIFI_STA);
	Serial.println("\r\nWait for Smartconfig");
	WiFi.beginSmartConfig();
	for (i = 0; i < 30; i++)
	{
	   Serial.print(".");
	   if(WiFi.smartConfigDone())
	   {
		  clear_Display();
		  char2Arr('O', 25, 0);
		  char2Arr('K', 19, 0);
		  char2Arr('!', 12, 0);
		  char2Arr('!', 6, 0);
		  refresh_display(); 
		  Serial.println("SmartConfig Success");
		  Serial.printf("SSID:%s\r\n", WiFi.SSID().c_str());
		  //Serial.printf("PSW:%s\r\n", WiFi.psk().c_str());
		  WiFi.setAutoConnect(true);			// 设置自动连接
		  
		  Serial.println("WiFi connected");
		  Serial.println(WiFi.localIP());
		  Serial.println("Starting UDP");
		  udp.begin(localPort);
		  Serial.print("Local port: ");
		  Serial.println(udp.localPort());
		  delay(1000); 
		  ESP.restart();
		  break;
	   }
	   clear_Display();
	   char2Arr('S', 29, 0);
	   char2Arr('-', 23, -1);
	   char2Arr('c', 17, 0);
	   char2Arr('o', 12, 0);
	   char2Arr('n', 6, 0);
	   refresh_display(); 
	   delay(1000);
	}
	if (i > 28)
	{
	   clear_Display();
	   char2Arr('R', 25, 0);
	   char2Arr('T', 19, 0);
	   char2Arr('C', 12, 0);
	   char2Arr('!', 6, 0);
	   refresh_display(); 
	   delay(1000);
	   Serial.println("SmartConfig Faild!" );
	   Serial.println("Clock use RTC!" );
	}
}
//**************************************************************************************************
tm* connectNTP()			//if response from NTP was succesfull return *tm else return a nullpointer
{
	WiFi.hostByName(ntpServerName, timeServerIP);
	Serial.println(timeServerIP);
	Serial.println("sending NTP packet...");
// set all bytes in the buffer to 0
	memset(packetBuffer, 0, NTP_PACKET_SIZE);
// Initialize values needed to form NTP request
// (see URL above for details on the packets)
	packetBuffer[0] = 0b11100011;			// LI, Version, Mode
	packetBuffer[1] = 0;			// Stratum, or type of clock
	packetBuffer[2] = 6;			// Polling Interval
	packetBuffer[3] = 0xEC;			// Peer Clock Precision
// 8 bytes of zero for Root Delay & Root Dispersion
	packetBuffer[12] = 49;
	packetBuffer[13] = 0x4E;
	packetBuffer[14] = 49;
	packetBuffer[15] = 52;
// all NTP fields have been given values, now
// you can send a packet requesting a timestamp:
	udp.beginPacket(timeServerIP, 123);			//NTP requests are to port 123
	udp.write(packetBuffer, NTP_PACKET_SIZE);
	udp.endPacket();
	delay(1000);			// wait to see if a reply is available
	int cb = udp.parsePacket();
	udp.read(packetBuffer, NTP_PACKET_SIZE);			// read the packet into the buffer
//the timestamp starts at byte 40 of the received packet and is four bytes,
// or two words, long. First, esxtract the two words:
	unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);
	unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);
// combine the four bytes (two words) into a long integer
// this is NTP time (seconds since Jan 1 1900):
	unsigned long secsSince1900 = highWord << 16 | lowWord;
// now convert NTP time into everyday time:
	const unsigned long seventyYears = 2208988800UL;
// subtract seventy years:
	const int SHIFT = -4; //时区
	const int VERA = 2; //+2000ms Verarbeitungszeit //+2000ms processing time
	epoch = secsSince1900 - seventyYears + 3600 * SHIFT + VERA;			
	time_t t;
	t = epoch;
	tm* tt;
	tt = localtime(&t);
	Serial.println(epoch);
	Serial.println(asctime(tt)); 
	if (cb == 48)
		return (tt);
	else
		return (NULL);
}
//**************************************************************************************************
void rtc_init(unsigned char sda, unsigned char scl) 
{
	Wire.begin(sda, scl);
	rtc_Write(controlREG, 0x00);
}
//**************************************************************************************************
// BCD Code
//**************************************************************************************************
unsigned char dec2bcd(unsigned char x) {			//value 0...99
	unsigned char z, e, r;
	e = x % 10;
	z = x / 10;
	z = z << 4;
	r = e | z;
	return (r);
}
unsigned char bcd2dec(unsigned char x) {			//value 0...99
	int z, e;
	e = x & 0x0F;
	z = x & 0xF0;
	z = z >> 4;
	z = z * 10;
	return (z + e);
}
//**************************************************************************************************
// RTC I2C Code
//**************************************************************************************************
unsigned char rtc_Read(unsigned char regaddress) {
	Wire.beginTransmission(DS3231_ADDRESS);
	Wire.write(regaddress);
	Wire.endTransmission();
	Wire.requestFrom((unsigned char) DS3231_ADDRESS, (unsigned char) 1);
	return (Wire.read());
}
void rtc_Write(unsigned char regaddress, unsigned char value) {
	Wire.beginTransmission(DS3231_ADDRESS);
	Wire.write(regaddress);
	Wire.write(value);
	Wire.endTransmission();
}
//**************************************************************************************************
unsigned char rtc_second() {
	return (bcd2dec(rtc_Read(secondREG)));
}
unsigned char rtc_minute() {
	return (bcd2dec(rtc_Read(minuteREG)));
}
unsigned char rtc_hour() {
	return (bcd2dec(rtc_Read(hourREG)));
}
unsigned char rtc_weekday() {
	return (bcd2dec(rtc_Read(WDREG)));
}
unsigned char rtc_day() {
	return (bcd2dec(rtc_Read(dateREG)));
}
unsigned char rtc_month() {
	return (bcd2dec(rtc_Read(monthREG)));
}
unsigned char rtc_year() {
	return (bcd2dec(rtc_Read(yearREG)));
}
void rtc_second(unsigned char sec) {
	rtc_Write(secondREG, (dec2bcd(sec)));
}
void rtc_minute(unsigned char min) {
	rtc_Write(minuteREG, (dec2bcd(min)));
}
void rtc_hour(unsigned char hr) {
	rtc_Write(hourREG, (dec2bcd(hr)));
}
void rtc_weekday(unsigned char wd) {
	rtc_Write(WDREG, (dec2bcd(wd)));
}
void rtc_day(unsigned char day) {
	rtc_Write(dateREG, (dec2bcd(day)));
}
void rtc_month(unsigned char mon) {
	rtc_Write(monthREG, (dec2bcd(mon)));
}
void rtc_year(unsigned char year) {
	rtc_Write(yearREG, (dec2bcd(year)));
}
//**************************************************************************************************
void rtc_set(tm* tt) {
	rtc_second((unsigned char) tt->tm_sec);
	rtc_minute((unsigned char) tt->tm_min);
	rtc_hour((unsigned char) tt->tm_hour);
	rtc_day((unsigned char) tt->tm_mday);
	rtc_month((unsigned char) tt->tm_mon + 1);
	rtc_year((unsigned char) tt->tm_year - 100);
	if (tt->tm_wday == 0)
	{
		rtc_weekday(7);
	}
	else
		rtc_weekday((unsigned char) tt->tm_wday);
}
//**************************************************************************************************
float rtc_temp() {
	float t = 0.0;
	unsigned char lowByte = 0;
	signed char highByte = 0;
	lowByte = rtc_Read(tempLSBREG);
	highByte = rtc_Read(tempMSBREG);
	lowByte >>= 6;
	lowByte &= 0x03;
	t = ((float) lowByte);
	t *= 0.25;
	t += highByte;
	return (t);			// return temp value
}
//**************************************************************************************************
void rtc2mez() {
 
	unsigned short Year, Day, Month, WeekDay, Hour, Minute, Second;

	Year = rtc_year();			//年
	if (Year > 99)
		Year = 0;
	Month = rtc_month();			//月
	if (Month > 12)
		Month = 0;
	Day = rtc_day();			//天
	if (Day > 31)
		Day = 0;
	WeekDay = rtc_weekday();			//星期
	if (WeekDay == 7)
		WeekDay = 0;
	Hour = rtc_hour();			//小时
	if (Hour > 23)
		Hour = 0;
	Minute = rtc_minute();			//分钟
	if (Minute > 59)
		Minute = 0;
	Second = rtc_second();			//秒
	if (Second > 59)
		Second = 0;
	
	MEZ.WD = WeekDay;			//日=0, 一=1, 二=2 ...
	MEZ.sec_ones = Second % 10;
	MEZ.sec_tens = Second / 10;
	MEZ.sec_whole = Second;
	MEZ.min_ones = Minute % 10;
	MEZ.min_tens = Minute / 10;
	MEZ.min_whole = Minute;
	MEZ.hr_ones = Hour % 10;
	MEZ.hr_tens = Hour / 10;
	MEZ.hr_whole = Hour;
	MEZ.day_whole = Day;
	MEZ.day_ones = Day % 10;
	MEZ.day_tens = Day / 10;
	MEZ.mon_whole = Month;
	MEZ.mon_ones = Month % 10;
	MEZ.mon_tens = Month / 10;
	MEZ.year_whole = Year;
	MEZ.year_ones = Year % 10;
	MEZ.year_tens = Year / 10;
}

//*************************************************************************************************
const unsigned short InitArr[7][2] = {	
		{ 0x0C, 0x00 },			// display off
		{ 0x00, 0xFF },			// no LEDtest
		{ 0x09, 0x00 },			// BCD off
		{ 0x0F, 0x00 },			// normal operation
		{ 0x0B, 0x07 },			// start display
		{ 0x0A, 0x04 },			// brightness
		{ 0x0C, 0x01 }			// display on
};
//**************************************************************************************************
void max7219_init()			//all MAX7219 init
{
	unsigned short i, j;
	for (i = 0; i < 7; i++) {
		digitalWrite(CS, LOW);
		delayMicroseconds(1);
		for (j = 0; j < anzMAX; j++) {
			SPI.write(InitArr[i][0]);			//register
			SPI.write(InitArr[i][1]);			//value
		}
		digitalWrite(CS, HIGH);
	}
}
//**************************************************************************************************
//亮度控制
void max7219_set_brightness(unsigned short br)			//brightness MAX7219
{
	unsigned short j;
	if (br < 16) {
		digitalWrite(CS, LOW);
		delayMicroseconds(1);
		for (j = 0; j < anzMAX; j++) {
			SPI.write(0x0A);			//register
			SPI.write(br);			//value
		}
		digitalWrite(CS, HIGH);
	}
}
//**************************************************************************************************
void helpArr_init(void)			//helperarray init
{
	unsigned short i, j, k;
	j = 0;
	k = 0;
	for (i = 0; i < anzMAX * 8; i++) {
		helpArrPos[i] = (1 << j);			//bitmask
		helpArrMAX[i] = k;
		j++;
		if (j > 7) {
			j = 0;
			k++;
		}
	}
}
//**************************************************************************************************
void clear_Display()			//clear all
{
	unsigned short i, j;
	for (i = 0; i < 8; i++)			//8 rows
	{
		digitalWrite(CS, LOW);
		delayMicroseconds(1);
		for (j = anzMAX; j > 0; j--) {
			LEDarr[j - 1][i] = 0;			//LEDarr clear
			SPI.write(i + 1);			//current row
			SPI.write(LEDarr[j - 1][i]);
		}
		digitalWrite(CS, HIGH);
	}
}
//*********************************************************************************************************
void rotate_90()			// for Generic displays
{
	for (uint8_t k = anzMAX; k > 0; k--) {

		uint8_t i, j, m, imask, jmask;
		uint8_t tmp[8]={0,0,0,0,0,0,0,0};
		for (  i = 0, imask = 0x01; i < 8; i++, imask <<= 1) {
		  for (j = 0, jmask = 0x01; j < 8; j++, jmask <<= 1) {
			if (LEDarr[k-1][i] & jmask) {
			  tmp[j] |= imask;
			}
		  }
		}
		for(m=0; m<8; m++){
			LEDarr[k-1][m]=tmp[m];
		}
	}
}
//**************************************************************************************************
void refresh_display()			//take info into LEDarr
{
	unsigned short i, j;

#ifdef ROTATE_90
	rotate_90();
#endif

	for (i = 0; i < 8; i++)			//8 rows
	{
		digitalWrite(CS, LOW);
		delayMicroseconds(1);
		for (j = 1; j <= anzMAX; j++) {
			SPI.write(i + 1);			//current row
			
#ifdef REVERSE_HORIZONTAL
			SPI.setBitOrder(LSBFIRST);			// bitorder for reverse columns
#endif

#ifdef REVERSE_VERTICAL
			SPI.write(LEDarr[j - 1][7-i]);
#else
			SPI.write(LEDarr[j - 1][i]);
#endif

#ifdef REVERSE_HORIZONTAL
			SPI.setBitOrder(MSBFIRST);			// reset bitorder
#endif
		}
		digitalWrite(CS, HIGH);
	}
}
//**************************************************************************************************
void char2Arr(unsigned short ch, int PosX, short PosY, unsigned short const typeface[96][9]) {			//characters into arr
	int i, j, k, l, m, o1, o2, o3, o4;			//in LEDarr
	PosX++;
	k = ch - 32;			//ASCII position in font
	if ((k >= 0) && (k < 96))			//character found in font?
	{
		o4 = typeface[k][0];			//character width
		o3 = 1 << (o4 - 2);
		for (i = 0; i < o4; i++) {
			if (((PosX - i <= maxPosX) && (PosX - i >= 0))
					&& ((PosY > -8) && (PosY < 8)))			//within matrix?
			{
				o1 = helpArrPos[PosX - i];
				o2 = helpArrMAX[PosX - i];
				for (j = 0; j < 8; j++) {
					if (((PosY >= 0) && (PosY <= j)) || ((PosY < 0) && (j < PosY + 8)))			//scroll vertical
					{
						l = typeface[k][j + 1];
						m = (l & (o3 >> i));			//e.g. o4=7  0zzzzz0, o4=4  0zz0
						if (m > 0)
							LEDarr[o2][j - PosY] = LEDarr[o2][j - PosY] | (o1);			//set point
						else
							LEDarr[o2][j - PosY] = LEDarr[o2][j - PosY] & (~o1);			//clear point
					}
				}
			}
		}
	}
}
// char2Arr for small font (font2)
void char22Arr(unsigned short ch, int PosX, short PosY) {	
	char2Arr(ch, PosX, PosY, font2);
}

//**************************************************************************************************
void timer50ms() {
	static unsigned int cnt50ms = 0;
	f_tckr50ms = true;
	cnt50ms++;
	if (cnt50ms == 20) {
		f_tckr1s = true;			// 1 sec
		cnt50ms = 0;
	}
}



//**************************************************************************************************
// # Main Functions 主函数

// ## The setup function is called once at startup of the sketch
void setup() 
{
// Add your initialization code here

	pinMode(CS, OUTPUT);
	digitalWrite(CS, HIGH);
	Serial.begin(115200);
	SPI.begin();
	helpArr_init();
	max7219_init();
	max7219_set_brightness(1);
	rtc_init(SDA, SCL);
	clear_Display();
	refresh_display();			//take info into LEDarr
	tckr.attach(0.05, timer50ms);			// every 50 msec
//////////////////////////////////
	if (!autoConfig())
	{
	   smartConfig();
	}
///////////////////////////////////
	tm* tt;
	tt = connectNTP();
	if (tt != NULL)
		rtc_set(tt);
	else
		Serial.println("no timepacket received");
}

//**************************************************************************************************
// ## The loop function is called in an endless loop
void loop() {
	unsigned int sec_ones = 0, sec_tens = 0, min_ones = 0, min_tens = 0, hr_ones = 0, hr_tens = 0;
	unsigned int sec_ones_old = 0, sec_ones_now = 0, sec_tens_old = 0, sec_tens_now = 0;
	unsigned int min_ones_old = 0, min_ones_now = 0, min_tens_old = 0, min_tens_now = 0;
	unsigned int hr_ones_old = 0, hr_ones_now = 0, hr_tens_old = 0, hr_tens_now = 0;
	signed int x = 0;			//x1,x2;
	signed int y = 0, y1 = 0, y2 = 0, y3=0;
	bool updown = false;
	unsigned int sc1 = 0, sc2 = 0, sc3 = 0, sc4 = 0, sc5 = 0, sc6 = 0;
	bool f_scrollend_y = false;
	unsigned int f_scroll_x = false;

	t_PosX = maxPosX;
	d_PosX = -8;
//  x=0; x1=0; x2=0;

	refresh_display();
	updown = true;
	if (updown == false) {
		y2 = -9;
		y1 = 8;
	}
	if (updown == true) {			//scroll  up to down
		y2 = 8;
		y1 = -8;
	}
	while (true) {
		yield();
//00:20自动同步，注意此处不能设为00:00；不然需要修改loop()开头处的初始值
		if ( MEZ.hr_whole==0 && MEZ.min_whole==20 && MEZ.sec_whole==0 )			//syncronisize RTC every day 00:20:00
		{ 
			clear_Display();
			delay(500);
			ESP.restart();
		}
		if (f_tckr1s == true)			// flag 1sec
		{
			rtc2mez();
			sec_ones = MEZ.sec_ones;
			sec_tens = MEZ.sec_tens;
			min_ones = MEZ.min_ones;
			min_tens = MEZ.min_tens;
			hr_ones = MEZ.hr_ones;
			hr_tens = MEZ.hr_tens;
			y = y2;			//scroll updown
			sc1 = 1;
			sec_ones++;
			if (sec_ones == 10) {
				sc2 = 1;
				sec_tens++;
				sec_ones = 0;
			}
			if (sec_tens == 6) {
				min_ones++;
				sec_tens = 0;
				sc3 = 1;
			}
			if (min_ones == 10) {
				min_tens++;
				min_ones = 0;
				sc4 = 1;
			}
			if (min_tens == 6) {
				hr_ones++;
				min_tens = 0;
				sc5 = 1;
			}
			if (hr_ones == 10) {
				hr_tens++;
				hr_ones = 0;
				sc6 = 1;
			}
			if ((hr_tens == 2) && (hr_ones == 4)) {
				hr_ones = 0;
				hr_tens = 0;
				sc6 = 1;
			}

			sec_ones_old = sec_ones_now;
			sec_ones_now = sec_ones;
			sec_tens_old = sec_tens_now;
			sec_tens_now = sec_tens;
			min_ones_old = min_ones_now;
			min_ones_now = min_ones;
			min_tens_old = min_tens_now;
			min_tens_now = min_tens;
			hr_ones_old = hr_ones_now;
			hr_ones_now = hr_ones;
			hr_tens_old = hr_tens_now;
			hr_tens_now = hr_tens;
			f_tckr1s = false;
			if (MEZ.sec_whole == 45)
				f_scroll_x = false;			//scroll switch
		}			// end 1s
		if (f_tckr50ms == true) {
			f_tckr50ms = false;
			if (f_scroll_x == true) {
				t_PosX++;
				d_PosX++;
				if (d_PosX == 62)
					t_PosX = 0;
				if (t_PosX == maxPosX) {
					f_scroll_x = false;
					d_PosX = -8;
				}
			}
			if (sc1 == 1) {
				if (updown == 1)
					y--;
				else
					y++;
			   y3 = y;
			   if (y3 > 0) {
				y3 = 0;
				}     
			   char22Arr(48 + sec_ones_now, t_PosX - 27, y3);
			   char22Arr(48 + sec_ones_old, t_PosX - 27, y + y1);
				if (y == 0) {
					sc1 = 0;
					f_scrollend_y = true;
				}
			}
			else
				char22Arr(48 + sec_ones, t_PosX - 27, 0);

			if (sc2 == 1) {
				char22Arr(48 + sec_tens_now, t_PosX - 23, y3);
				char22Arr(48 + sec_tens_old, t_PosX - 23, y + y1);
				if (y == 0)
					sc2 = 0;
			}
			else
			  char22Arr(48 + sec_tens, t_PosX - 23, 0);

			if (sc3 == 1) {
				char2Arr(48 + min_ones_now, t_PosX - 18, y);
				char2Arr(48 + min_ones_old, t_PosX - 18, y + y1);
				if (y == 0)
					sc3 = 0;
			}
			else
				char2Arr(48 + min_ones, t_PosX - 18, 0);

			if (sc4 == 1) {
				char2Arr(48 + min_tens_now, t_PosX - 13, y);
				char2Arr(48 + min_tens_old, t_PosX - 13, y + y1);
				if (y == 0)
					sc4 = 0;
			}
			else
				char2Arr(48 + min_tens, t_PosX - 13, 0);

			  char2Arr(':', t_PosX - 10 + x, 0);

			if (sc5 == 1) {
				char2Arr(48 + hr_ones_now, t_PosX - 4, y);
				char2Arr(48 + hr_ones_old, t_PosX - 4, y + y1);
				if (y == 0)
					sc5 = 0;
			}
			else
				char2Arr(48 + hr_ones, t_PosX - 4, 0);

			if (sc6 == 1) {
				char2Arr(48 + hr_tens_now, t_PosX + 1, y);
				char2Arr(48 + hr_tens_old, t_PosX + 1, y + y1);
				if (y == 0)
					sc6 = 0;
			}
			else
				char2Arr(48 + hr_tens, t_PosX + 1, 0);

			char2Arr(' ', d_PosX+5, 0); 
			
		   
			char2Arr(M_arr[MEZ.mon_whole - 1][0], d_PosX, 0);			//month
			char2Arr(M_arr[MEZ.mon_whole - 1][1], d_PosX - 6, 0);
			char2Arr(M_arr[MEZ.mon_whole - 1][2], d_PosX - 12, 0);
			
			char2Arr(48 + MEZ.day_tens, d_PosX - 18, 0);			//day
			char2Arr(48 + MEZ.day_ones, d_PosX - 24, 0);

			char2Arr(WD_arr[MEZ.WD][0], d_PosX - 36, 0);			//day of the week
			char2Arr(WD_arr[MEZ.WD][1], d_PosX - 42, 0);
			char2Arr(WD_arr[MEZ.WD][2], d_PosX - 48, 0);

			refresh_display();			//alle 50ms
			if (f_scrollend_y == true) {
				f_scrollend_y = false;
			}
		}			//end 50ms
		if (y == 0) {
// do something else
		}
	}			//end while(true)
//this section can not be reached
}
